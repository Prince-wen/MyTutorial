package com.shiwen.tutorial.Scala2_Operator

/**
 * @author Shiwen Li
 * @account CN116237626
 * @create 2021-03-17 15:58
 * @note 运算符
 */
object Operator {

  /**
   * scala运算符的使用和Java运算符的使用基本相同，只有个别细节上不同。
   */

  //todo 算数运算符
  /**
   * 假定变量 A 为 10，B 为 20
   * 运算符    描述    实例
   *   +      加号    A+B 运算结果为 30
   *   -      减号    A-B 运算结果为 -10
   *   *      乘号    A*B 运算结果为 200
   *   /      除号    B/A 运算结果为 2
   *   %      取余    B%A 运算结果为 0
   */

  //todo 关系运算符
  /**
   * 假定变量A为10，B为20
   * 运算符    描述        实例
   *  ==      等于        (A==B)运算结果为 false
   *  !=      不等于      (A!=B)运算结果为 true
   *  >       大于        (A> B)运算结果为 false
   *  <       小于        (A< B)运算结果为 true
   *  >=      大于等于     (A>=B)运算结果为 false
   *  <=      小于等于     (A<=B)运算结果为 true
   */
  def main1(args: Array[String]): Unit = {
    //思考一个问题：如下代码执行结果如何？
    val a = new String("abc")
    val b = new String("abc")
    println(a == b)
    println(a.equals(b))
  }

  //todo 赋值运算符
  /**
   * 运算符    描述                                                实例
   * =        简单的赋值运算，指定右边操作数赋值给左边的操作数            C=A+B将A+B的运算结果赋值给C
   * +=       相加后再赋值，将左右两边的操作数相加后再赋值给左边的操作数    C+=A相当于C=C+A
   * -=       相减后再赋值，将左右两边的操作数相减后再赋值给左边的操作数    C-=A相当于C=C-A
   * *=       相乘后再赋值，将左右两边的操作数相乘后再赋值给左边的操作数    C*=A相当于C=C*A
   * /=       相除后再赋值，将左右两边的操作数相除后再赋值给左边的操作数    C/=A相当于C=C/A
   * %=       求余后再赋值，将左右两边的操作数求余后再赋值给左边的操作数    C%=A相当于C=C%A
   * <<=      按位左移后再赋值                                      C<<=A相当于C=C<<A
   * >>=      按位右移后再赋值                                      C>>=A相当于C=C>>A
   * &=       按位与运算后再赋值                                     C&=A相当于C=C&A
   * ^=       按位异或运算后再赋值                                   C^=A相当于C=C^A
   * |=       按位或运算后再赋值                                     C|=A相当于C=C|A
   */

  //思考一个问题：为什么在上面的运算符中没有看到 ++， --？

  //todo 逻辑运算符
  /**
   * 假定变量 A 为 1，B 为 0
   * 运算符    描述      实例
   * &&       逻辑与     (A&&B)运算结果为false
   * ||       逻辑或     (A||B)运算结果为true
   * !        逻辑非     !(A&&B)运算结果为true
   */

  //todo 位运算符
  /**
   * 如果指定 A = 60; 及 B = 13; 两个变量对应的二进制为
   * A = 0011 1100
   * B = 0000 1101
   * 运算符  描述          实例
   * &      按位与运算符    (a&b)输出结果12，二进制解释: 0000 1100
   * |      按位或运算符    (a|b)输出结果61，二进制解释: 0011 1101
   * ^      按位异或运算符   (a^b)输出结果49，二进制解释: 0011 0001
   * ~      按位取反运算符   (~a)输出结果-61，二进制解释: 1100 0011,在一个有符号二进制数的补码形式。
   * <<     左移动运算符    a<<2输出结果240，二进制解释: 1111 0000
   * >>     右移动运算符    a>>2输出结果15，二进制解释: 0000 1111
   * >>>    无符号右移      a>>>2输出结果15，二进制解释: 0000 1111
   *
   * 思考一个问题：有啥用？你用过吗或你接触过吗？
   */

  //todo 运算符本质
  /**
   * 在Scala中其实是没有运算符的，所有运算符都是方法。
   * 	scala是完全面向对象的语言，所以数字其实也是对象
   * 	当调用对象的方法时，点.可以省略
   * 	如果函数参数只有一个，或者没有参数，()可以省略
   */
  def main(args: Array[String]): Unit = {
    val i : Int = 10
    val j : Int = i.+(10)
    val k : Int = j +(20)
    val m : Int = k + 30
    println(m)
  }
}
